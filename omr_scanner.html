<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced OMR Answer Sheet Scanner</title>
    <script src="https://docs.opencv.org/4.x/opencv.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-section {
            border: 2px dashed #ddd;
            padding: 30px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 30px;
            transition: all 0.3s ease;
        }
        .upload-section:hover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }
        .file-input {
            margin: 10px 0;
            padding: 10px;
        }
        .processing-status {
            margin: 20px 0;
            padding: 15px;
            border-radius: 5px;
            display: none;
        }
        .status-info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .results-section {
            display: none;
            margin-top: 30px;
        }
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 10px;
            max-width: 100%;
        }
        .student-info {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .answers-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .answer-block {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .answer-correct { border-left-color: #28a745; background: #d4edda; }
        .answer-incorrect { border-left-color: #dc3545; background: #f8d7da; }
        .score-summary {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #ffeeba;
            margin: 20px 0;
        }
        .btn {
            background: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        .btn:hover { background: #0056b3; }
        .debug-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Advanced OMR Answer Sheet Scanner</h1>
        
        <div class="upload-section">
            <h3>üìÑ Upload OMR Answer Sheet</h3>
            <p>Upload a clear photo of your OMR answer sheet. The system will automatically detect and process it.</p>
            <input type="file" id="fileInput" accept="image/*" class="file-input">
            <br>
            <button onclick="processUploadedImage()" class="btn">üîç Scan Answer Sheet</button>
        </div>

        <div id="processingStatus" class="processing-status">
            <span id="statusText">Processing...</span>
        </div>

        <div id="resultsSection" class="results-section">
            <div class="canvas-container">
                <h3>üì∏ Processed Images</h3>
                <div>
                    <label>Original Image:</label><br>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div>
                    <label>Processed Image:</label><br>
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>

            <div id="studentInfo" class="student-info">
                <h3>üë§ Student Information</h3>
                <p><strong>Name:</strong> <span id="studentName">Detecting...</span></p>
                <p><strong>Subject:</strong> <span id="subject">Detecting...</span></p>
            </div>

            <div class="score-summary">
                <h3>üìä Scan Results</h3>
                <p><strong>Score:</strong> <span id="totalScore">0/0</span></p>
                <p><strong>Percentage:</strong> <span id="percentage">0%</span></p>
                <p><strong>Questions Processed:</strong> <span id="questionsProcessed">0</span></p>
            </div>

            <div id="answersGrid" class="answers-grid">
                <!-- Answers will be populated here -->
            </div>

            <div id="debugInfo" class="debug-info">
                <h4>üîß Debug Information</h4>
                <div id="debugContent"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let uploadedImage = null;
        let answerKey = {};
        let debugLog = [];
        
        // Initialize answer key (you can modify this based on your needs)
        function initializeAnswerKey() {
            // Sample answer key - you can load this from a file or API
            const sampleAnswers = ["A", "B", "C", "D"];
            for (let i = 1; i <= 60; i++) {
                answerKey[i] = sampleAnswers[Math.floor(Math.random() * sampleAnswers.length)];
            }
            log("Answer key initialized for 60 questions");
        }

        // Logging function
        function log(message) {
            console.log(message);
            debugLog.push(`${new Date().toLocaleTimeString()}: ${message}`);
            updateDebugInfo();
        }

        function updateDebugInfo() {
            document.getElementById('debugContent').innerHTML = debugLog.slice(-10).join('<br>');
        }

        function showStatus(message, type = 'info') {
            const statusEl = document.getElementById('processingStatus');
            const statusText = document.getElementById('statusText');
            
            statusEl.style.display = 'block';
            statusText.textContent = message;
            
            statusEl.className = `processing-status status-${type}`;
            
            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // File input handling
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const img = new Image();
            img.onload = function() {
                uploadedImage = img;
                showStatus('Image loaded successfully!', 'success');
                log(`Image loaded: ${file.name} (${img.width}x${img.height})`);
            };
            img.src = URL.createObjectURL(file);
        });

        function processUploadedImage() {
            if (!uploadedImage) {
                showStatus('Please upload an image first!', 'error');
                return;
            }

            showStatus('Processing OMR sheet...', 'info');
            initializeAnswerKey();
            
            try {
                processOMRSheet(uploadedImage);
            } catch (error) {
                log(`Error processing image: ${error.message}`);
                showStatus('Error processing image. Please try again.', 'error');
            }
        }

        function processOMRSheet(img) {
            log("Starting OMR processing...");
            
            // Step 1: Load image into OpenCV
            const src = cv.imread(img);
            log(`Image loaded into OpenCV: ${src.cols}x${src.rows}`);

            // Step 2: Preprocess image
            const processed = preprocessImage(src);
            
            // Step 3: Extract student information
            extractStudentInfo(src);
            
            // Step 4: Detect and analyze bubbles
            const detectedAnswers = detectBubbles(processed);
            
            // Step 5: Display results
            displayResults(src, processed, detectedAnswers);
            
            // Cleanup
            src.delete();
            processed.delete();
        }

        function preprocessImage(src) {
            log("Preprocessing image...");
            
            // Convert to grayscale
            const gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            
            // Apply bilateral filter to reduce noise while preserving edges
            const bilateral = new cv.Mat();
            cv.bilateralFilter(gray, bilateral, 9, 75, 75);
            
            // Enhance contrast using CLAHE
            const clahe = new cv.Mat();
            const claheAlgo = new cv.CLAHE(3.0, new cv.Size(8, 8));
            claheAlgo.apply(bilateral, clahe);
            
            // Apply Otsu's thresholding
            const thresh = new cv.Mat();
            cv.threshold(clahe, thresh, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
            
            // Morphological operations to clean up the image
            const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
            const morphed = new cv.Mat();
            cv.morphologyEx(thresh, morphed, cv.MORPH_OPEN, kernel);
            
            log("Enhanced image preprocessing completed");
            
            // Cleanup intermediate mats
            gray.delete();
            bilateral.delete();
            clahe.delete();
            thresh.delete();
            kernel.delete();
            
            return morphed;
        }

        function extractStudentInfo(src) {
            log("Extracting student information...");
            
            // Extract name region (top portion of the sheet)
            const nameRegion = src.roi(new cv.Rect(0, 0, src.cols, Math.floor(src.rows * 0.15)));
            
            // Convert to canvas for OCR
            const canvas = document.createElement('canvas');
            cv.imshow(canvas, nameRegion);
            
            // Use Tesseract.js for OCR
            Tesseract.recognize(canvas, 'eng', {
                logger: m => {
                    if (m.status === 'recognizing text') {
                        log(`OCR Progress: ${Math.round(m.progress * 100)}%`);
                    }
                }
            }).then(({ data: { text } }) => {
                log(`OCR Result: ${text}`);
                parseStudentInfo(text);
                nameRegion.delete();
            }).catch(error => {
                log(`OCR Error: ${error.message}`);
                document.getElementById('studentName').textContent = 'Could not detect';
                document.getElementById('subject').textContent = 'Could not detect';
                nameRegion.delete();
            });
        }

        function parseStudentInfo(text) {
            // Parse the OCR text to extract name and subject
            const lines = text.split('\n').filter(line => line.trim());
            let name = 'Could not detect';
            let subject = 'Could not detect';
            
            // Look for name patterns
            for (let line of lines) {
                if (line.toLowerCase().includes('name') || line.length > 10) {
                    // Extract text after "name" or longest line
                    name = line.replace(/name[:\s]*/i, '').trim();
                    if (name.length > 3) break;
                }
            }
            
            // Look for subject
            const subjects = ['MATH', 'SCIENCE', 'ENGLISH', 'HISTORY', 'PHYSICS', 'CHEMISTRY', 'BIOLOGY'];
            for (let line of lines) {
                const upperLine = line.toUpperCase();
                for (let subj of subjects) {
                    if (upperLine.includes(subj)) {
                        subject = subj;
                        break;
                    }
                }
                if (subject !== 'Could not detect') break;
            }
            
            document.getElementById('studentName').textContent = name;
            document.getElementById('subject').textContent = subject;
            log(`Parsed - Name: ${name}, Subject: ${subject}`);
        }

        function detectBubbles(processedImg) {
            log("Detecting bubble answers...");
            
            const detectedAnswers = {};
            const imgHeight = processedImg.rows;
            const imgWidth = processedImg.cols;
            
            // Constants based on the actual answer sheet layout
            const questionsPerColumn = 15;  // 15 questions per column
            const numColumns = 4;  // 4 columns to get 60 questions total
            
            // Calculate the answer section boundaries (approximately 60% of the page height)
            const startY = Math.floor(imgHeight * 0.55); // Start where the answer section begins
            const endY = Math.floor(imgHeight * 0.95);
            const questionHeight = (endY - startY) / questionsPerColumn;
            
            // Log dimensions for debugging
            console.log({imgHeight, imgWidth, questionsPerColumn, numColumns, startY, endY, questionHeight});
            
            // Bubble dimensions based on actual sheet measurements
            const bubbleWidth = Math.floor(imgWidth * 0.02);  // Smaller bubbles to match sheet
            const bubbleHeight = Math.floor(questionHeight * 0.5); // Adjust height to match actual bubbles
            const bubbleSpacing = Math.floor(bubbleWidth * 1.5);  // Closer spacing between options
            
            let totalQuestions = 0;
            
            // Process four columns of questions
            for (let col = 0; col < numColumns; col++) {
                // Calculate column positions to match the actual sheet layout
                const colStartX = Math.floor(imgWidth * (0.15 + col * 0.2)); // Evenly space 4 columns
                
                for (let q = 0; q < questionsPerColumn; q++) {
                    const questionNum = col * questionsPerColumn + q + 1;
                    if (questionNum > 60) break;
                    
                    totalQuestions++;
                    const questionY = startY + q * questionHeight;
                    
                    let bestAnswer = null;
                    let maxFilled = 0;
                    let debugInfo = [];
                    
                    // Check each option (A, B, C, D)
                    const options = ['A', 'B', 'C', 'D'];
                    for (let i = 0; i < options.length; i++) {
                        const option = options[i];
                        const bubbleX = colStartX + i * bubbleSpacing;
                        
                        try {
                            // Extract and analyze bubble region
                            const bubbleRect = new cv.Rect(
                                Math.max(0, bubbleX), 
                                Math.max(0, questionY),
                                Math.min(bubbleWidth, imgWidth - bubbleX),
                                Math.min(bubbleHeight, imgHeight - questionY)
                            );
                            
                            if (bubbleRect.width > 0 && bubbleRect.height > 0) {
                                const roi = processedImg.roi(bubbleRect);
                                
                                // Count black pixels (marked areas)
                                const nonZeroPixels = cv.countNonZero(roi);
                                const totalPixels = roi.rows * roi.cols;
                                const fillRatio = nonZeroPixels / totalPixels;
                                
                                debugInfo.push(`${option}:${Math.round(fillRatio * 100)}%`);
                                
                                roi.delete();
                                
                                // Adjusted threshold for better detection
                                if (fillRatio > 0.2 && fillRatio > maxFilled) {  // Lower threshold for better detection
                                    bestAnswer = option;
                                    maxFilled = fillRatio;
                                }
                            }
                        } catch (error) {
                            log(`Error processing Q${questionNum}${option}: ${error.message}`);
                        }
                    }
                    
                    detectedAnswers[questionNum] = bestAnswer || '-';
                    // log(`Q${questionNum} - Fill ratios: ${debugInfo.join(', ')} -> Selected: ${bestAnswer || '-'}`);
                }
            }
            
            log(`Bubble detection completed. Processed ${totalQuestions} questions.`);
            return detectedAnswers;
        }

        function displayResults(originalImg, processedImg, detectedAnswers) {
            log("Displaying results...");
            
            // Create a copy for visualization
            const visualImg = originalImg.clone();
            const color = new cv.Scalar(0, 255, 0, 255); // Green color for visualization
            
            // Draw detected bubble regions
            const imgHeight = processedImg.rows;
            const imgWidth = processedImg.cols;
            const questionsPerColumn = 15;  // 15 questions per column
            const numColumns = 4;  // 4 columns for 60 questions
            const startY = Math.floor(imgHeight * 0.55); // Start at answer section
            const endY = Math.floor(imgHeight * 0.95);
            const questionHeight = (endY - startY) / questionsPerColumn;
            const bubbleWidth = Math.floor(imgWidth * 0.02);
            const bubbleHeight = Math.floor(questionHeight * 0.5);
            const bubbleSpacing = Math.floor(bubbleWidth * 1.5);
            
            // Draw grid and detected answers
            for (let col = 0; col < numColumns; col++) {
                const colStartX = Math.floor(imgWidth * (0.15 + col * 0.2)); // Match the detection spacing
                
                for (let q = 0; q < questionsPerColumn; q++) {
                    const questionNum = col * questionsPerColumn + q + 1;
                    if (questionNum > 60) break;
                    
                    const questionY = startY + q * questionHeight;
                    const answer = detectedAnswers[questionNum];
                    
                    // Draw all bubble positions
                    for (let i = 0; i < 4; i++) {
                        const option = ['A', 'B', 'C', 'D'][i];
                        const bubbleX = colStartX + i * bubbleSpacing;
                        
                        // Draw rectangle for each bubble position
                        const pt1 = new cv.Point(bubbleX, questionY);
                        const pt2 = new cv.Point(bubbleX + bubbleWidth, questionY + bubbleHeight);
                        
                        // Highlight detected answer in green, others in red
                        const bubbleColor = option === answer ? 
                            new cv.Scalar(0, 255, 0, 255) : // Green for selected
                            new cv.Scalar(255, 0, 0, 255);  // Red for others
                            
                        cv.rectangle(visualImg, pt1, pt2, bubbleColor, 1);
                    }
                    
                    // Add question number
                    const textPt = new cv.Point(colStartX - 20, questionY + bubbleHeight);
                    cv.putText(visualImg, questionNum.toString(), textPt, cv.FONT_HERSHEY_SIMPLEX, 0.4, color, 1);
                }
            }
            
            // Show images
            cv.imshow('originalCanvas', visualImg);
            cv.imshow('processedCanvas', processedImg);
            
            // Cleanup
            visualImg.delete();
            
            // Calculate score
            let correctAnswers = 0;
            const totalQuestions = Object.keys(detectedAnswers).length;
            
            const answersGrid = document.getElementById('answersGrid');
            answersGrid.innerHTML = '';
            
            for (let q in detectedAnswers) {
                const studentAnswer = detectedAnswers[q];
                const correctAnswer = answerKey[q];
                const isCorrect = studentAnswer === correctAnswer;
                
                if (isCorrect && studentAnswer !== '-') {
                    correctAnswers++;
                }
                
                // Create answer display element
                const answerDiv = document.createElement('div');
                answerDiv.className = `answer-block ${isCorrect ? 'answer-correct' : 'answer-incorrect'}`;
                answerDiv.innerHTML = `
                    <strong>Q${q}:</strong> ${studentAnswer || '-'}<br>
                    <small>Correct: ${correctAnswer}</small>
                `;
                answersGrid.appendChild(answerDiv);
            }
            
            // Update score display
            const percentage = totalQuestions > 0 ? Math.round((correctAnswers / totalQuestions) * 100) : 0;
            document.getElementById('totalScore').textContent = `${correctAnswers}/${totalQuestions}`;
            document.getElementById('percentage').textContent = `${percentage}%`;
            document.getElementById('questionsProcessed').textContent = totalQuestions;
            
            // Show results section
            document.getElementById('resultsSection').style.display = 'block';
            showStatus('OMR processing completed!', 'success');
            
            log(`Results displayed - Score: ${correctAnswers}/${totalQuestions} (${percentage}%)`);
        }

        // Initialize when OpenCV is ready
        function onOpenCvReady() {
            log("OpenCV.js is ready!");
            showStatus('System ready - upload an OMR sheet to begin', 'success');
        }

        // Wait for OpenCV to load
        if (typeof cv !== 'undefined') {
            onOpenCvReady();
        } else {
            var script = document.createElement('script');
            script.onload = onOpenCvReady;
            script.src = 'https://docs.opencv.org/4.x/opencv.js';
            document.head.appendChild(script);
        }
    </script>
</body>
</html>
